# STM32H750XBH6 Project - AI Coding Assistant Guide

## Project Overview

This is an STM32H7 embedded firmware project for the **STM32H750XBH6** microcontroller (Cortex-M7, 480MHz) using:
- **STM32CubeMX** for peripheral configuration
- **CMake** build system with Ninja generator
- **arm-none-eabi-gcc** toolchain
- **STM32 HAL** (Hardware Abstraction Layer) drivers

## Critical Architecture Patterns

### STM32CubeMX Code Generation Workflow

**NEVER manually edit auto-generated sections** - STM32CubeMX will overwrite them on regeneration.

User code must ONLY be added within protected sections:
```c
/* USER CODE BEGIN [Section] */
// Your code here - safe from regeneration
/* USER CODE END [Section] */
```

**Safe files to edit**: Any code within `USER CODE` blocks in `Core/Src/*.c` and `Core/Inc/*.h`  
**DO NOT TOUCH**: 
- `cmake/stm32cubemx/CMakeLists.txt` (auto-generated)
- GPIO initialization, peripheral MspInit/MspDeInit functions (except within USER CODE blocks)
- `Drivers/` directory (ST HAL/CMSIS library code)

### Hardware Configuration (STM32H750XBH6)

**MCU Specs:**
- **Flash**: 128KB only (bootloader MCU - typically requires external flash)
- **RAM**: 1MB total across 4 regions:
  - DTCMRAM: 128KB @ 0x20000000 (data, stack, heap - default)
  - AXI SRAM: 512KB @ 0x24000000
  - SRAM1/2/3: 288KB @ 0x30000000 (D2 domain)
  - SRAM4: 64KB @ 0x38000000 (D3 domain)
  - ITCMRAM: 64KB @ 0x00000000 (instruction)

**Active Peripherals (see `Core/Inc/stm32h7xx_hal_conf.h`):**
- FMC (Flexible Memory Controller) with SDRAM interface @ 0xC0000000 (32MB)
- MPU configured for external memory region
- I-Cache and D-Cache enabled in `main()`
- MPU_Config() runs before HAL_Init()

**Memory Map** (see `STM32H750XX_FLASH.ld`):
- `.data` and `.bss` → DTCMRAM
- Stack: top of DTCMRAM (`_estack`)
- External SDRAM: 0xC0000000, configure via FMC

## Build System

### CMake Configuration

**Two-layer CMake structure:**

1. **Root `CMakeLists.txt`**: User application sources/libraries
   - Add user code to sections marked `# Add user sources here`
   - Link custom libraries via `target_link_libraries()`

2. **`cmake/stm32cubemx/CMakeLists.txt`**: Auto-generated by CubeMX
   - Contains HAL drivers, startup code, peripheral init code
   - Defines `stm32cubemx` INTERFACE library and `STM32_Drivers` OBJECT library
   - **Do not manually edit** - regenerate via CubeMX

**Toolchain:** `cmake/gcc-arm-none-eabi.cmake`
- Cortex-M7 flags: `-mcpu=cortex-m7 -mfpu=fpv5-d16 -mfloat-abi=hard`
- Linker script: `STM32H750XX_FLASH.ld`
- nano.specs for minimal C library
- Debug: `-O0 -g3`, Release: `-Os -g0`

### Build Commands

```powershell
# Configure (Debug preset)
cmake --preset Debug

# Build
cmake --build build/Debug

# Or Release
cmake --preset Release
cmake --build build/Release
```

**Output**: `build/Debug/STM32H750XBH6.elf` + `.map` file

## Development Workflow

### Adding New HAL Peripherals

1. Open `STM32H750XBH6.ioc` in STM32CubeMX GUI
2. Enable peripheral (e.g., UART, SPI, USB)
3. Configure pinout and parameters
4. **Generate Code** (Project → Generate Code)
5. CubeMX regenerates:
   - Peripheral init files (e.g., `uart.c`, `uart.h`)
   - Updates `cmake/stm32cubemx/CMakeLists.txt`
   - Preserves all `USER CODE` sections
6. Add your logic in `USER CODE BEGIN/END` blocks

### Adding User Application Code

**For new source files:**
1. Create in application directories (not `Core/` which is CubeMX-managed)
2. Add to root `CMakeLists.txt`:
```cmake
target_sources(${CMAKE_PROJECT_NAME} PRIVATE
    my_app/sensor.c
    my_app/display.c
)
target_include_directories(${CMAKE_PROJECT_NAME} PRIVATE
    my_app/inc
)
```

### Memory Constraints

**Critical**: STM32H750 has only **128KB flash** - unsuitable for large applications without external flash/bootloader strategy.

When adding code:
- Monitor `.map` file for flash usage
- Consider moving large buffers to external SDRAM (0xC0000000)
- Use `__attribute__((section(".sdram")))` for SDRAM placement (requires linker script modification)

## Common Patterns

### HAL Error Handling
All HAL functions return `HAL_StatusTypeDef`:
```c
if (HAL_UART_Transmit(&huart1, data, len, 1000) != HAL_OK) {
    Error_Handler();  // Infinite loop in main.c
}
```

### Interrupt Handling
- ISR callbacks defined in `Core/Src/stm32h7xx_it.c` (auto-generated)
- User logic goes in weak function overrides or USER CODE sections:
```c
/* USER CODE BEGIN 0 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    // Your interrupt callback
}
/* USER CODE END 0 */
```

### Clock Configuration
`SystemClock_Config()` in `main.c` is auto-generated:
- HSE 25MHz → PLL → 480MHz SYSCLK (max for STM32H750)
- Modify via CubeMX Clock Configuration tool, not manually

## Project-Specific Notes

- **C11 required** - C90/C99 incompatible (see `cmake/stm32cubemx/CMakeLists.txt`)
- **FMC SDRAM configured but clock disabled**: `FMC_SDRAM_CLOCK_DISABLE` in `fmc.c` - likely needs initialization sequence in user code
- **No RTOS** currently - bare-metal super-loop in `main()`
- **No debugging interface configured** - likely needs SWD/JTAG pins setup in CubeMX

## File Organization

```
Core/               # CubeMX-generated application code
├── Src/            # Peripheral init, main loop, interrupts
└── Inc/            # Headers, HAL config

Drivers/            # ST provided libraries (read-only)
├── STM32H7xx_HAL_Driver/
└── CMSIS/

cmake/
├── gcc-arm-none-eabi.cmake    # Toolchain file
└── stm32cubemx/               # Auto-generated build config

startup_stm32h750xx.s          # Reset handler, vector table
STM32H750XX_FLASH.ld           # Linker script - memory layout
STM32H750XBH6.ioc              # CubeMX project file
```

## Key References

- MCU: STM32H750XBH6 datasheet/reference manual
- HAL drivers: `Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_*.c`
- Enabled HAL modules: see `HAL_*_MODULE_ENABLED` in `Core/Inc/stm32h7xx_hal_conf.h`
